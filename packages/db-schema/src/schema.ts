import { sqliteTable, text, integer, real, primaryKey, index } from 'drizzle-orm/sqlite-core';
import { relations, sql } from 'drizzle-orm';

// === Core Tables ===

export const mitras = sqliteTable('mitras', {
  id: text('id').primaryKey(), // Public ID (CUID2 generated by app)
  ownerUserId: text('owner_user_id').notNull().unique(), // From CF Access email
  name: text('name').notNull(),
  createdAt: integer('created_at', { mode: 'timestamp_ms' }).notNull().default(sql`(unixepoch('subsec') * 1000)`),
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' }).notNull().default(sql`(unixepoch('subsec') * 1000)`),
});

export const services = sqliteTable('services', {
  id: text('id').primaryKey(),
  mitraId: text('mitra_id').notNull().references(() => mitras.id, { onDelete: 'cascade' }),
  name: text('name').notNull(), // User-facing service alias
  // Core service type from a predefined enum, e.g., 'P2P_EXPRESS', 'SCHEDULED_MULTIDROP'
  // This could inform which Zod schema to use for configJson validation.
  serviceTypeKey: text('service_type_key').notNull(),
  configJson: text('config_json', { mode: 'json' }).notNull(), // Store validated ServiceConfigBase
  isActive: integer('is_active', { mode: 'boolean' }).default(true).notNull(),
  createdAt: integer('created_at', { mode: 'timestamp_ms' }).notNull().default(sql`(unixepoch('subsec') * 1000)`),
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' }).notNull().default(sql`(unixepoch('subsec') * 1000)`),
}, (table) => ({
  mitraIdIdx: index('services_mitra_id_idx').on(table.mitraId),
  serviceTypeIdx: index('services_service_type_idx').on(table.serviceTypeKey),
  activeIdx: index('services_active_idx').on(table.isActive),
}));

export const drivers = sqliteTable('drivers', {
  id: text('id').primaryKey(),
  mitraId: text('mitra_id').notNull().references(() => mitras.id, { onDelete: 'cascade' }),
  identifier: text('identifier').notNull(), // e.g., email or unique code per Mitra
  name: text('name'),
  // JSON string for vehicle type, capabilities (e.g., ambulance facilities)
  configJson: text('config_json', { mode: 'json' }), // Optional, simpler config for driver
  isActive: integer('is_active', { mode: 'boolean' }).default(true).notNull(),
  createdAt: integer('created_at', { mode: 'timestamp_ms' }).notNull().default(sql`(unixepoch('subsec') * 1000)`),
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' }).notNull().default(sql`(unixepoch('subsec') * 1000)`),
}, (table) => ({
  mitraIdIdentifierIdx: index('drivers_mitra_id_identifier_idx').on(table.mitraId, table.identifier), // For unique check per mitra
  activeIdx: index('drivers_active_idx').on(table.isActive),
}));

export const driverServices = sqliteTable('driver_services', {
  driverId: text('driver_id').notNull().references(() => drivers.id, { onDelete: 'cascade' }),
  serviceId: text('service_id').notNull().references(() => services.id, { onDelete: 'cascade' }),
}, (table) => ({
  pk: primaryKey({ columns: [table.driverId, table.serviceId] }),
  serviceIdIdx: index('driver_services_service_id_idx').on(table.serviceId),
}));

export const orders = sqliteTable('orders', {
  id: text('id').primaryKey(), // Public Order ID (CUID2)
  serviceId: text('service_id').notNull().references(() => services.id, { onDelete: 'restrict' }), // Restrict delete if orders exist
  mitraId: text('mitra_id').notNull().references(() => mitras.id, { onDelete: 'restrict' }), // Denormalized for easier querying by Mitra
  driverId: text('driver_id').references(() => drivers.id, { onDelete: 'set null' }), // Set null if driver deleted
  ordererIdentifier: text('orderer_identifier').notNull(), // e.g., phone number
  receiverWaNumber: text('receiver_wa_number'),
  // JSON for pickup_address, dropoff_address, notes, talangan_amount, selected_muatan etc.
  // This will be validated against the service.configJson rules at order creation.
  detailsJson: text('details_json', { mode: 'json' }).notNull(),
  status: text('status').notNull().default('PENDING'), // Use OrderStatus enum from shared-types
  estimatedCost: real('estimated_cost'),
  finalCost: real('final_cost'),
  createdAt: integer('created_at', { mode: 'timestamp_ms' }).notNull().default(sql`(unixepoch('subsec') * 1000)`),
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' }).notNull().default(sql`(unixepoch('subsec') * 1000)`),
  scheduledAt: integer('scheduled_at', { mode: 'timestamp_ms' }), // For scheduled orders
}, (table) => ({
  serviceIdIdx: index('orders_service_id_idx').on(table.serviceId),
  mitraIdIdx: index('orders_mitra_id_idx').on(table.mitraId),
  driverIdIdx: index('orders_driver_id_idx').on(table.driverId),
  statusIdx: index('orders_status_idx').on(table.status),
  createdAtIdx: index('orders_created_at_idx').on(table.createdAt),
  ordererIdx: index('orders_orderer_idx').on(table.ordererIdentifier),
  scheduledAtIdx: index('orders_scheduled_at_idx').on(table.scheduledAt),
}));

export const orderEvents = sqliteTable('order_events', {
  id: text('id').primaryKey(), // CUID2
  orderId: text('order_id').notNull().references(() => orders.id, { onDelete: 'cascade' }),
  timestamp: integer('timestamp', { mode: 'timestamp_ms' }).notNull().default(sql`(unixepoch('subsec') * 1000)`),
  eventType: text('event_type').notNull(), // e.g., STATUS_UPDATE, PHOTO_UPLOADED, DRIVER_NOTE
  // JSON for event-specific data (e.g., new_status, old_status, photo_r2_key, notes, actor_type, actor_id)
  dataJson: text('data_json', { mode: 'json' }),
  actorType: text('actor_type'), // 'USER', 'DRIVER', 'MITRA_ADMIN', 'SYSTEM'
  actorId: text('actor_id'), // ID of the actor
}, (table) => ({
  orderIdTimestampIdx: index('order_events_order_id_timestamp_idx').on(table.orderId, table.timestamp),
  eventTypeIdx: index('order_events_event_type_idx').on(table.eventType),
  actorIdx: index('order_events_actor_idx').on(table.actorType, table.actorId),
}));

// === Drizzle Relations ===

export const mitraRelations = relations(mitras, ({ many }) => ({
  services: many(services),
  drivers: many(drivers),
  orders: many(orders),
}));

export const serviceRelations = relations(services, ({ one, many }) => ({
  mitra: one(mitras, { fields: [services.mitraId], references: [mitras.id] }),
  driverServices: many(driverServices),
  orders: many(orders),
}));

export const driverRelations = relations(drivers, ({ one, many }) => ({
  mitra: one(mitras, { fields: [drivers.mitraId], references: [mitras.id] }),
  driverServices: many(driverServices),
  orders: many(orders),
}));

export const driverServiceRelations = relations(driverServices, ({ one }) => ({
  driver: one(drivers, { fields: [driverServices.driverId], references: [drivers.id] }),
  service: one(services, { fields: [driverServices.serviceId], references: [services.id] }),
}));

export const orderRelations = relations(orders, ({ one, many }) => ({
  service: one(services, { fields: [orders.serviceId], references: [services.id] }),
  mitra: one(mitras, { fields: [orders.mitraId], references: [mitras.id] }),
  driver: one(drivers, { fields: [orders.driverId], references: [drivers.id] }),
  events: many(orderEvents),
}));

export const orderEventRelations = relations(orderEvents, ({ one }) => ({
  order: one(orders, { fields: [orderEvents.orderId], references: [orders.id] }),
})); 